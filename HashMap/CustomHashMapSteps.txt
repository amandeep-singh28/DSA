Task -> We have to create a custom hashmap of any data Type(OPEN HASHING)

->We will make a class with the help of genrics because data type can be of any type.
    static class MyHashMap<K, V> {}
Inside this class we will implement all of the functions.

->There are two things DEFAULT_CAPACITY and LOAD_FACTOR. So we need firstly initialize these two things.
    public static final int DEFAULT_CAPACITY = 4;
    public static final float DEFAULT_LOAD_FACTOR = 0.75f;

->To create the linked list, we need to create a node which will store key and value.
    private class Node {
            K key;
            V value;
            Node(K key, V value) {
                this.key = key;
                this.value = value;
            }
        }

->We need to create 4 main functions to do this task, size(), put(K key, V Value), get(K key), remove(K key).

->Now we need to create hashtable(Array of linked list nodes)
    private LinkedList<Node>[] buckets;
After that, we need to initialize empty linked list to every index of the hash table.
    private void initBuckets(int N) { // N - capacity/size of buckets array
            buckets = new LinkedList[N];
            for (int i = 0; i < buckets.length; i++) {
                buckets[i] = new LinkedList<>();
            }

        }

->PUT()
Firstly we need to find the index of the every key using hash function.
    private int HashFunc(K key) {
            int hc = key.hashCode();
            //Problem -> The hachcode which we are getting, it can be of any length and hc can come in negative also.
            //Solution -> We need to % the value.
            return (Math.abs(hc) % buckets.length);
        }
Now for putting the value, firstly we need to find out whether that key exists in our hashtable or not. If exists update the value and if not create a node.
    private int searchInBucket(LinkedList<Node> ll, K key) { // Traverse the ll and looks for a node with key, if found it returns it's index otherwise it returns null
            for (int i = 0; i < ll.size(); i++) {
                if (ll.get(i).key == key) {
                    return i;
                }
            }
            return -1;
             
        }

    public void put(K key, V value) { // insert / update
            int bi = HashFunc(key);
            LinkedList<Node> currBucket = buckets[bi];
            int ei = searchInBucket(currBucket, key);
            if (ei != -1) { // key doesn't exist, we have to insert a new node
                Node node = new Node(key, value);
                currBucket.add(node);
                n++;
            } else { // Update case
                Node currNode = currBucket.get(ei);
                currNode.value = value;
            }
        }

->GET()
Firstly we need to find out the bucket index.
Then we need to search whether that key is present or not(For that we have already created a function).
After that, we need to traverse through the linkedlist, if key is there print its value otherwise return null.
    public V get(K key) {
            int bi = HashFunc(key);
            LinkedList<Node> currBucket = buckets[bi];
            int ei = searchInBucket(currBucket, key);
            if (ei != -1) {// key exists
                Node currNode = currBucket.get(ei);
                return currNode.value;
            }
            return null;
        }

->REMOVE()
Same functionality
    public V remove(K key) {
            int bi = HashFunc(key);
            LinkedList<Node> currBucket = buckets[bi];
            int ei = searchInBucket(currBucket, key);
            if (ei != -1) { // key exists
                Node currNode = currBucket.get(ei);
                V val = currNode.value;
                currBucket.remove(ei);
                n--;
                return val;
            }
            return null; // if key doesn't exists
        }

->REHASHING
If n >= threshold value, than it is required to do the rehashing.
We have to create new bucket with length (previous bucket * 2) and then intialize this new bucket with the empty linked list nodes like we have done previously and than we need to copy the elements from the previous bucket to the newly created bucket.
    private void reHash() {
            LinkedList<Node>[] oldBuckets = buckets;
            initBuckets(oldBuckets.length * 2);
            n = 0;
            for (var bucket : oldBuckets) {
                for (var node : bucket) {
                    put(node.key, node.value);
                }
            }
        }
        
